(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{754:function(a,v,t){a.exports=t.p+"assets/img/image-20200801220853666.78732fff.png"},755:function(a,v,t){a.exports=t.p+"assets/img/image-20200802000512777.6d8b042a.png"},756:function(a,v,t){a.exports=t.p+"assets/img/image-20200802003201069.7385dfaa.png"},757:function(a,v,t){a.exports=t.p+"assets/img/image-20200802012453141.51f9c27d.png"},830:function(a,v,t){"use strict";t.r(v);var _=t(18),s=Object(_.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"java-基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-基础"}},[a._v("#")]),a._v(" Java 基础")]),a._v(" "),_("h2",{attrs:{id:"代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[a._v("#")]),a._v(" 代码")]),a._v(" "),_("p",[a._v("Java/JavaProgrammingBasics")]),a._v(" "),_("h2",{attrs:{id:"视频地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#视频地址"}},[a._v("#")]),a._v(" 视频地址")]),a._v(" "),_("p",[_("a",{attrs:{href:"https://www.bilibili.com/video/BV12J41137hu",target:"_blank",rel:"noopener noreferrer"}},[a._v("【狂神说 Java】Java 零基础学习视频通俗易懂"),_("OutboundLink")],1)]),a._v(" "),_("h2",{attrs:{id:"p16-入门-04-jdk-jre-jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#p16-入门-04-jdk-jre-jvm"}},[a._v("#")]),a._v(" P16 入门 04 JDK JRE JVM")]),a._v(" "),_("p",[a._v("JDK: Java 开发环境")]),a._v(" "),_("p",[a._v("JRE: 运行环境")]),a._v(" "),_("p",[a._v("JVM: Java 虚拟机")]),a._v(" "),_("p",[a._v("JDK 包含 JRE")]),a._v(" "),_("p",[a._v("JRE 包含 JVM")]),a._v(" "),_("p",[a._v("通过 JVM 实现跨平台")]),a._v(" "),_("h2",{attrs:{id:"p19-编译型和解释型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#p19-编译型和解释型"}},[a._v("#")]),a._v(" P19 编译型和解释型")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("编译型")]),a._v(" "),_("p",[a._v("一次性翻译完 再读 执行速度快些")])]),a._v(" "),_("li",[_("p",[a._v("解释型")]),a._v(" "),_("p",[a._v("读一句翻译一句 执行速度慢些")])])]),a._v(" "),_("h2",{attrs:{id:"idea-快捷键"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#idea-快捷键"}},[a._v("#")]),a._v(" IDEA 快捷键")]),a._v(" "),_("ul",[_("li",[a._v("sout = System.out.println();")]),a._v(" "),_("li",[a._v("psvm = Java 类中的 main 方法")])]),a._v(" "),_("h2",{attrs:{id:"注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[a._v("#")]),a._v(" 注释")]),a._v(" "),_("p",[a._v("平时写代码一定要写注释")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("单行注释")]),a._v(" "),_("p",[a._v("//")])]),a._v(" "),_("li",[_("p",[a._v("多行注释")]),a._v(" "),_("p",[a._v("/* 回车")])]),a._v(" "),_("li",[_("p",[a._v("Java doc 文档注释")]),a._v(" "),_("p",[a._v("/** 回车")])])]),a._v(" "),_("h2",{attrs:{id:"数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("强类型语言")]),a._v(" "),_("p",[a._v("要求变量的使用要严格符合规定, 所有变量都必须先定义再使用")])]),a._v(" "),_("li",[_("p",[a._v("弱类型语言")])])]),a._v(" "),_("h3",{attrs:{id:"数据类型分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型分类"}},[a._v("#")]),a._v(" 数据类型分类")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("八大基本类型")]),a._v(" "),_("p",[a._v("int float double char boolean 等")])]),a._v(" "),_("li",[_("p",[a._v("引用类型")]),a._v(" "),_("p",[a._v("类 String Byte 等")]),a._v(" "),_("p",[a._v("接口")]),a._v(" "),_("p",[a._v("数组")])])]),a._v(" "),_("h3",{attrs:{id:"字节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字节"}},[a._v("#")]),a._v(" 字节")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("位(bit)")]),a._v(" "),_("p",[a._v("计算机 内部数据 储存的最小单位 1100 1100 为 八位 二进制数. 二进制数有多少位就几个位")])]),a._v(" "),_("li",[_("p",[a._v("字节(byte)")]),a._v(" "),_("p",[a._v("计算机中 数据处理 的基本单位 习惯用大写 B 表示")]),a._v(" "),_("p",[a._v("1B(byte) = 8bit(位)")])]),a._v(" "),_("li",[_("p",[a._v("字符")])])]),a._v(" "),_("h3",{attrs:{id:"整数扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#整数扩展"}},[a._v("#")]),a._v(" 整数扩展")]),a._v(" "),_("h3",{attrs:{id:"转义字符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转义字符"}},[a._v("#")]),a._v(" 转义字符")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("\\t")]),a._v(" "),_("p",[a._v("Tab 键")])]),a._v(" "),_("li",[_("p",[a._v("\\n")]),a._v(" "),_("p",[a._v("回车键")])])]),a._v(" "),_("h2",{attrs:{id:"类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[a._v("#")]),a._v(" 类型转换")]),a._v(" "),_("ul",[_("li",[a._v("强制类型转换\n"),_("ul",[_("li",[a._v("不能对 bool 类型转换")]),a._v(" "),_("li",[a._v("不能把对象类型转换位不相干的类型")]),a._v(" "),_("li",[a._v("在把高容量转到低容量的时候 强制转换")]),a._v(" "),_("li",[a._v("可能有内存溢出 或者 精度问题")]),a._v(" "),_("li")])]),a._v(" "),_("li",[a._v("自动类型转换")])]),a._v(" "),_("h2",{attrs:{id:"idea-快捷输入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#idea-快捷输入"}},[a._v("#")]),a._v(" IDEA 快捷输入")]),a._v(" "),_("p",[a._v("100.for: for 循环快捷键")]),a._v(" "),_("p",[a._v("main: 主方法")]),a._v(" "),_("p",[a._v("new Scanner(System.in); 然后 alt + enter 会补充前面的对象.new 其他对象是一样的.")]),a._v(" "),_("p",[a._v("sout: System.out.printline();")]),a._v(" "),_("h2",{attrs:{id:"break-和-countine"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#break-和-countine"}},[a._v("#")]),a._v(" break 和 countine")]),a._v(" "),_("p",[a._v("用于循环结构")]),a._v(" "),_("p",[a._v("break: 退出当前循环, 直接退出循环程序")]),a._v(" "),_("p",[a._v("countine: 退出当前小循环, 进入下一个循环")]),a._v(" "),_("h2",{attrs:{id:"方法重载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法重载"}},[a._v("#")]),a._v(" 方法重载")]),a._v(" "),_("p",[a._v("一个类中多个同名方法 参数 返回值可不同")]),a._v(" "),_("h2",{attrs:{id:"命令行传参-和-可变参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#命令行传参-和-可变参数"}},[a._v("#")]),a._v(" 命令行传参 和 可变参数")]),a._v(" "),_("h2",{attrs:{id:"递归"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[a._v("#")]),a._v(" 递归")]),a._v(" "),_("h2",{attrs:{id:"数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),_("h3",{attrs:{id:"array-类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#array-类"}},[a._v("#")]),a._v(" Array 类")]),a._v(" "),_("p",[a._v("看源码")]),a._v(" "),_("h3",{attrs:{id:"稀疏数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#稀疏数组"}},[a._v("#")]),a._v(" 稀疏数组")]),a._v(" "),_("h2",{attrs:{id:"面向对象编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程"}},[a._v("#")]),a._v(" 面向对象编程")]),a._v(" "),_("ul",[_("li",[a._v("封装")]),a._v(" "),_("li",[a._v("继承")]),a._v(" "),_("li",[a._v("多态")])]),a._v(" "),_("h3",{attrs:{id:"静态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[a._v("#")]),a._v(" 静态方法")]),a._v(" "),_("p",[a._v("调用: 类名.方法名")]),a._v(" "),_("h3",{attrs:{id:"非静态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非静态方法"}},[a._v("#")]),a._v(" 非静态方法")]),a._v(" "),_("p",[a._v("只能先 new 类 在调用")]),a._v(" "),_("p",[_("img",{attrs:{src:t(754),alt:"image-20200801220853666"}})]),a._v(" "),_("p",[a._v("static 中的方法不能调用非 static 的方法")]),a._v(" "),_("h3",{attrs:{id:"创造对象内存分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创造对象内存分析"}},[a._v("#")]),a._v(" 创造对象内存分析")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("new 一个对象的时候会在 堆中放入对象的数据 在栈中生成对象名字------\x3e指向 堆中对应的对象(指针, 地址), 是引用传递")]),a._v(" "),_("p",[_("img",{attrs:{src:t(755),alt:"image-20200802000512777"}})])])]),a._v(" "),_("h3",{attrs:{id:"封装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[a._v("#")]),a._v(" 封装")]),a._v(" "),_("p",[a._v("属性私有 private 和 get set 方法")]),a._v(" "),_("h3",{attrs:{id:"重载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[a._v("#")]),a._v(" 重载")]),a._v(" "),_("p",[a._v("多个同名方法 参数或者返回类型不同")]),a._v(" "),_("h3",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("只有单继承")])]),a._v(" "),_("li",[_("p",[a._v("子类继承父类的所有 属性 和 公共方法(私有方法不继承)")])]),a._v(" "),_("li",[_("p",[a._v("Java 中 所有类都继承或间接继承 Object 类 所以会有一些自带方法")])]),a._v(" "),_("li",[_("p",[a._v("super")]),a._v(" "),_("ul",[_("li",[a._v("super 调用父类构造方法 必须在构造方法的第一个")]),a._v(" "),_("li",[a._v("super 必须只能出现在子类的方法或构造方法中")]),a._v(" "),_("li",[a._v("super 和 this 不能同时调用构造方法")])])]),a._v(" "),_("li",[_("p",[a._v("this 和 super")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("对象:")]),a._v(" "),_("p",[a._v("this 本身调用者这个对象")]),a._v(" "),_("p",[a._v("super: 代表父类对象")])]),a._v(" "),_("li",[_("p",[a._v("前提:")]),a._v(" "),_("p",[a._v("this: 没有继承也可以使用")]),a._v(" "),_("p",[a._v("super: 只能在继承条件才可以使用")])]),a._v(" "),_("li",[_("p",[a._v("构造方法")]),a._v(" "),_("p",[a._v("this: 本类的构造")]),a._v(" "),_("p",[a._v("super: 父类的构造")])])])])]),a._v(" "),_("p",[_("img",{attrs:{src:t(756),alt:"image-20200802003201069"}})]),a._v(" "),_("ul",[_("li",[_("p",[a._v("方法重写")]),a._v(" "),_("p",[a._v("需要有继承关系, 子类重写父类的方法")]),a._v(" "),_("ol",[_("li",[a._v("方法名相同")]),a._v(" "),_("li",[a._v("参数相同")]),a._v(" "),_("li",[a._v("修饰符 范围可以扩大不能缩小. Public > proctect > default> private")]),a._v(" "),_("li",[a._v("抛出的异常 可以缩小 不能扩大 ClassNotFoundException(小) --\x3eException(大)")])])]),a._v(" "),_("li",[_("p",[a._v("多态")]),a._v(" "),_("ul",[_("li",[a._v("方法的多态")]),a._v(" "),_("li",[a._v("父类和子类有关系, 否则会类型转换异常")]),a._v(" "),_("li",[a._v("存在条件: 继承关系 方法需要重写 父类引用指向子类对象")])])])]),a._v(" "),_("h3",{attrs:{id:"java-值传递"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-值传递"}},[a._v("#")]),a._v(" Java 值传递")]),a._v(" "),_("p",[a._v("java 是值传递: 复制一分参数给函数")]),a._v(" "),_("p",[a._v("对象是引用传递(指针)")]),a._v(" "),_("h3",{attrs:{id:"static-关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static-关键字"}},[a._v("#")]),a._v(" static 关键字")]),a._v(" "),_("p",[a._v("静态方法和变量 和类一起加载, 能直接调用 不用新建对象.")]),a._v(" "),_("p",[a._v("其他非静态的变量和方法必须先 new 对象后使用")]),a._v(" "),_("p",[a._v("记住这句话就会使用了")]),a._v(" "),_("ul",[_("li",[a._v("被 final 修饰的类 不能被继承")])]),a._v(" "),_("h4",{attrs:{id:"static-静态代码块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static-静态代码块"}},[a._v("#")]),a._v(" static 静态代码块")]),a._v(" "),_("p",[a._v("只执行一次")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  方法\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("h4",{attrs:{id:"静态导入包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态导入包"}},[a._v("#")]),a._v(" 静态导入包")]),a._v(" "),_("h3",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),_("ul",[_("li",[a._v("类/方法 上使用 abstract 关键字, 只有方法/类的名字 没有实现")]),a._v(" "),_("li",[a._v("一个类中有 抽象方法就必须声明为抽象类 抽象类中可以有普通方法")])]),a._v(" "),_("h3",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[a._v("#")]),a._v(" 接口")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("接口仅定义方法. 不实现")])]),a._v(" "),_("li",[_("p",[a._v("利用接口实现多继承")])])]),a._v(" "),_("p",[_("img",{attrs:{src:t(757),alt:"image-20200802012453141"}})]),a._v(" "),_("ul",[_("li",[a._v("接口作用\n"),_("ul",[_("li",[_("ol",[_("li",[a._v("约束")]),a._v(" "),_("li",[a._v("定义一些方法, 让不同人实现")]),a._v(" "),_("li",[a._v("方法都是 public abstract")]),a._v(" "),_("li",[a._v("接口不能被实例化, 没有构造方法")]),a._v(" "),_("li",[a._v("implements 可以实现多个接口")]),a._v(" "),_("li",[a._v("必须要重写接口中的方法")])])])])])]),a._v(" "),_("h2",{attrs:{id:"异常机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常机制"}},[a._v("#")]),a._v(" 异常机制")]),a._v(" "),_("h3",{attrs:{id:"error-和-exception"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#error-和-exception"}},[a._v("#")]),a._v(" Error 和 Exception")]),a._v(" "),_("p",[a._v("Error: 致命")]),a._v(" "),_("p",[a._v("Exception: 可处理")]),a._v(" "),_("h3",{attrs:{id:"捕获异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#捕获异常"}},[a._v("#")]),a._v(" 捕获异常")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("关键字")]),a._v(" "),_("p",[a._v("try catch finally throw throws")])]),a._v(" "),_("li",[_("p",[a._v("捕获多个异常 由上到下 异常范围由小到大")])]),a._v(" "),_("li",[_("p",[a._v("throw")]),a._v(" "),_("p",[a._v("主动抛出异常, 一般在方法中使用, 假设在方法中不能处理异常")])])]),a._v(" "),_("h3",{attrs:{id:"自定义异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义异常"}},[a._v("#")]),a._v(" 自定义异常")])])}),[],!1,null,null,null);v.default=s.exports}}]);