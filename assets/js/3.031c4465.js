(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{402:function(t,a,s){t.exports=s.p+"assets/img/image-20200907143445874.c2fa4441.png"},403:function(t,a,s){t.exports=s.p+"assets/img/image-20200907144454206.62b3effb.png"},404:function(t,a,s){t.exports=s.p+"assets/img/image-20200907144606663.1d9e7be3.png"},405:function(t,a,s){t.exports=s.p+"assets/img/image-20200907144822852.78e823b5.png"},406:function(t,a,s){t.exports=s.p+"assets/img/image-20200907145103910.5ebc3272.png"},407:function(t,a,s){t.exports=s.p+"assets/img/image-20200912105621460.f33c55c1.png"},408:function(t,a,s){t.exports=s.p+"assets/img/image-20200912112452782.f0f86724.png"},409:function(t,a,s){t.exports=s.p+"assets/img/image-20200912112736246.3a2f8209.png"},410:function(t,a,s){t.exports=s.p+"assets/img/image-20200912113049647.90d59c05.png"},411:function(t,a,s){t.exports=s.p+"assets/img/image-20200912113226526.b9152c8f.png"},412:function(t,a,s){t.exports=s.p+"assets/img/image-20200912122411718.e21e78d8.png"},413:function(t,a,s){t.exports=s.p+"assets/img/image-20200912123407232.8873f161.png"},414:function(t,a,s){t.exports=s.p+"assets/img/image-20200912123525328.d533f818.png"},415:function(t,a,s){t.exports=s.p+"assets/img/image-20200912123758154.f018029a.png"},416:function(t,a,s){t.exports=s.p+"assets/img/image-20200912154919164.00d3d766.png"},417:function(t,a){t.exports="data:image/png;base64,"},418:function(t,a,s){t.exports=s.p+"assets/img/image-20200912155614534.c5641a34.png"},419:function(t,a,s){t.exports=s.p+"assets/img/image-20200912160634487.d47ff828.png"},420:function(t,a,s){t.exports=s.p+"assets/img/image-20200912161158592.c2675821.png"},421:function(t,a,s){t.exports=s.p+"assets/img/image-20200912162007672.4310f985.png"},422:function(t,a,s){t.exports=s.p+"assets/img/image-20200912162455785.c577c1e3.png"},423:function(t,a,s){t.exports=s.p+"assets/img/image-20200912230653681.91acca97.png"},424:function(t,a,s){t.exports=s.p+"assets/img/image-20200912230832388.17963313.png"},425:function(t,a,s){t.exports=s.p+"assets/img/image-20200912231112979.dce4af6a.png"},426:function(t,a,s){t.exports=s.p+"assets/img/image-20200912231442246.40dd5d2d.png"},427:function(t,a,s){t.exports=s.p+"assets/img/image-20200912233512633.8faa2c9c.png"},428:function(t,a,s){t.exports=s.p+"assets/img/image-20200912233646465.18a9c3e7.png"},429:function(t,a,s){t.exports=s.p+"assets/img/image-20200912233816269.b4199f13.png"},430:function(t,a,s){t.exports=s.p+"assets/img/image-20200912233905973.4e873c42.png"},431:function(t,a,s){t.exports=s.p+"assets/img/image-20200912234149536.5143d2f6.png"},432:function(t,a,s){t.exports=s.p+"assets/img/image-20200913001816883.35b0c7d3.png"},433:function(t,a,s){t.exports=s.p+"assets/img/image-20200913002045030.42f47516.png"},434:function(t,a,s){t.exports=s.p+"assets/img/image-20200913084731669.00325ca3.png"},435:function(t,a,s){t.exports=s.p+"assets/img/image-20200913085115325.fbf9d0f9.png"},436:function(t,a,s){t.exports=s.p+"assets/img/image-20200913090059839.33dcfa76.png"},437:function(t,a,s){t.exports=s.p+"assets/img/image-20200913091308912.47347bef.png"},438:function(t,a,s){t.exports=s.p+"assets/img/image-20200913091757522.f323bcd7.png"},439:function(t,a,s){t.exports=s.p+"assets/img/image-20200913092003834.54963764.png"},440:function(t,a,s){t.exports=s.p+"assets/img/image-20200913092137171.2e6a43fb.png"},441:function(t,a,s){t.exports=s.p+"assets/img/image-20200913092805271.000010f8.png"},442:function(t,a,s){t.exports=s.p+"assets/img/image-20200913092922964.b7804156.png"},443:function(t,a,s){t.exports=s.p+"assets/img/image-20200913093150196.b550fe8b.png"},444:function(t,a,s){t.exports=s.p+"assets/img/image-20200913101209154.fa9ac937.png"},445:function(t,a,s){t.exports=s.p+"assets/img/image-20200913101647714.0eaa04d0.png"},446:function(t,a,s){t.exports=s.p+"assets/img/image-20200913103315003.416e650a.png"},447:function(t,a,s){t.exports=s.p+"assets/img/image-20200913104805278.aeaedca9.png"},448:function(t,a,s){t.exports=s.p+"assets/img/image-20200913105549442.ede3df33.png"},449:function(t,a,s){t.exports=s.p+"assets/img/image-20200913110121688.fed1b8ca.png"},450:function(t,a,s){t.exports=s.p+"assets/img/image-20200913110330650.f7a79816.png"},451:function(t,a,s){t.exports=s.p+"assets/img/image-20200913110449691.f4d3ee87.png"},452:function(t,a,s){t.exports=s.p+"assets/img/image-20200913111638445.f23a2020.png"},453:function(t,a,s){t.exports=s.p+"assets/img/image-20200913112612511.224c1c4f.png"},454:function(t,a,s){t.exports=s.p+"assets/img/image-20200913112923610.445ecbcf.png"},455:function(t,a,s){t.exports=s.p+"assets/img/image-20200913114215040.be78ebd1.png"},456:function(t,a,s){t.exports=s.p+"assets/img/image-20200913171054983.0a6c8392.png"},809:function(t,a,s){"use strict";s.r(a);var r=s(18),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.bilibili.com/video/BV1JW411i731?p=3&t=69",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构-浙江大学"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"第一章-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一章-算法"}},[t._v("#")]),t._v(" 第一章 算法")]),t._v(" "),r("h3",{attrs:{id:"_1-1-3-关于算法效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-关于算法效率"}},[t._v("#")]),t._v(" 1.1.3 关于算法效率")]),t._v(" "),r("h3",{attrs:{id:"_1-1-4-抽象数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-4-抽象数据类型"}},[t._v("#")]),t._v(" 1.1.4 抽象数据类型")]),t._v(" "),r("h3",{attrs:{id:"_1-2-1-算法的定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-算法的定义"}},[t._v("#")]),t._v(" 1.2.1 算法的定义")]),t._v(" "),r("p",[t._v("算法不关心具体细节")]),t._v(" "),r("h3",{attrs:{id:"_1-2-2-什么是好的算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-什么是好的算法"}},[t._v("#")]),t._v(" 1.2.2 什么是好的算法")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("空间复杂度")]),t._v(" "),r("p",[t._v("执行算法时占用的存储单元长度")])]),t._v(" "),r("li",[r("p",[t._v("时间复杂度")]),t._v(" "),r("p",[t._v("算法执行时间长度")])])]),t._v(" "),r("h4",{attrs:{id:"递归调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#递归调用"}},[t._v("#")]),t._v(" 递归调用")]),t._v(" "),r("p",[t._v("调用其他函数时, 会将当前函数保存到内存中, 当内层函数执行之后再执行外层函数. 若递归调用函数数量过多时, 会造成 堆栈溢出, 使得程序异常退出.")]),t._v(" "),r("h4",{attrs:{id:"例-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#例-3"}},[t._v("#")]),t._v(" 例 3")]),t._v(" "),r("ul",[r("li",[t._v("计算机做加减法速度远快于乘除法, 粗略估计复杂度看计算乘除法的次数")])]),t._v(" "),r("h4",{attrs:{id:"分析一般算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分析一般算法"}},[t._v("#")]),t._v(" 分析一般算法")]),t._v(" "),r("p",[t._v("关注:")]),t._v(" "),r("ul",[r("li",[t._v("最坏情况复杂度 T_worst(n)")]),t._v(" "),r("li",[t._v("平均复杂度 T_avg(n)")])]),t._v(" "),r("p",[t._v("平均复杂度不好区分, 最关心的是最坏情况复杂度")]),t._v(" "),r("h3",{attrs:{id:"_1-2-3-复杂度的渐进表示法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-复杂度的渐进表示法"}},[t._v("#")]),t._v(" 1.2.3 复杂度的渐进表示法")]),t._v(" "),r("p",[t._v("不对算法复杂度最精细的分析, 只分析出, 在 n 很大时, n 的多少次方起主要作用. 这就是渐进式表示法")]),t._v(" "),r("p",[r("img",{attrs:{src:s(402),alt:"image-20200907143445874"}})]),t._v(" "),r("p",[t._v("上面的内容简单来说:")]),t._v(" "),r("p",[t._v("我们算法有一个时间复杂度")]),t._v(" "),r("p",[t._v("O(f(n))可以取很多个, 但是我们一般取最接近此算法时间复杂度的上界")]),t._v(" "),r("p",[t._v("Ω(f(n))可以取很多个, 但是我们取最接近此算法时间复杂度下界")]),t._v(" "),r("p",[t._v("若此算法的时间复杂度可找到一条接近的线, 则用 θ(h(n))表示")]),t._v(" "),r("h4",{attrs:{id:"输入规模"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#输入规模"}},[t._v("#")]),t._v(" 输入规模")]),t._v(" "),r("p",[r("img",{attrs:{src:s(403),alt:"image-20200907144454206"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(404),alt:"image-20200907144606663"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(405),alt:"image-20200907144822852"}})]),t._v(" "),r("h4",{attrs:{id:"复杂度分析小窍门"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析小窍门"}},[t._v("#")]),t._v(" 复杂度分析小窍门")]),t._v(" "),r("p",[r("img",{attrs:{src:s(406),alt:"image-20200907145103910"}})]),t._v(" "),r("ul",[r("li",[t._v("两个算法相加, 总时间复杂度取时间复杂度最大的一个")]),t._v(" "),r("li",[t._v("两个算法相乘(算法嵌套): 时间复杂度相乘")])]),t._v(" "),r("h3",{attrs:{id:"_1-3-1-应用实例算法-1-2-最大子列和问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-应用实例算法-1-2-最大子列和问题"}},[t._v("#")]),t._v(" 1.3.1 应用实例算法 1&2: 最大子列和问题")]),t._v(" "),r("p",[t._v("最大子列和问题 : "),r("img",{attrs:{src:s(407),alt:"image-20200912105621460"}})]),t._v(" "),r("h3",{attrs:{id:"_1-3-2-应用实例算法-3-最大子列和问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-应用实例算法-3-最大子列和问题"}},[t._v("#")]),t._v(" 1.3.2 应用实例算法 3: 最大子列和问题")]),t._v(" "),r("h3",{attrs:{id:"_1-3-3-应用实例算法-4-最大子列和问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-3-应用实例算法-4-最大子列和问题"}},[t._v("#")]),t._v(" 1.3.3 应用实例算法 4: 最大子列和问题")]),t._v(" "),r("h2",{attrs:{id:"第二章-线性表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二章-线性表"}},[t._v("#")]),t._v(" 第二章 线性表")]),t._v(" "),r("h3",{attrs:{id:"_2-2-1-引子-多项式表示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-引子-多项式表示"}},[t._v("#")]),t._v(" 2.2.1 引子: 多项式表示")]),t._v(" "),r("p",[r("img",{attrs:{src:s(408),alt:"image-20200912112452782"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(409),alt:"image-20200912112736246"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(410),alt:"image-20200912113049647"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(411),alt:"image-20200912113226526"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-2-线性表及其顺序存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-线性表及其顺序存储"}},[t._v("#")]),t._v(" 2.1.2 线性表及其顺序存储")]),t._v(" "),r("p",[r("img",{attrs:{src:s(412),alt:"image-20200912122411718"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-3-顺序存储的插入和删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-顺序存储的插入和删除"}},[t._v("#")]),t._v(" 2.1.3 顺序存储的插入和删除")]),t._v(" "),r("p",[r("img",{attrs:{src:s(413),alt:"image-20200912123407232"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(414),alt:"image-20200912123525328"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(415),alt:"image-20200912123758154"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-4-链式存储及查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-链式存储及查找"}},[t._v("#")]),t._v(" 2.1.4 链式存储及查找")]),t._v(" "),r("p",[r("img",{attrs:{src:s(416),alt:"image-20200912154919164"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(417),alt:"image-20200912155136158"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(418),alt:"image-20200912155614534"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-5-链式存储的插入和删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-链式存储的插入和删除"}},[t._v("#")]),t._v(" 2.1.5 链式存储的插入和删除")]),t._v(" "),r("p",[r("img",{attrs:{src:s(419),alt:"image-20200912160634487"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(420),alt:"image-20200912161158592"}})]),t._v(" "),r("ul",[r("li",[t._v("插入在表头和其他位置有区别, 要分开写")]),t._v(" "),r("li",[t._v("s -> Next =p ->Next 和 p -> Next =s; 顺序不能交换.")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(421),alt:"image-20200912162007672"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(422),alt:"image-20200912162455785"}})]),t._v(" "),r("h3",{attrs:{id:"_2-1-6-广义表与多重链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-广义表与多重链表"}},[t._v("#")]),t._v(" 2.1.6 广义表与多重链表")]),t._v(" "),r("h4",{attrs:{id:"广义表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广义表"}},[t._v("#")]),t._v(" 广义表")]),t._v(" "),r("p",[r("img",{attrs:{src:s(423),alt:"image-20200912230653681"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(424),alt:"image-20200912230832388"}})]),t._v(" "),r("h4",{attrs:{id:"多重链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多重链表"}},[t._v("#")]),t._v(" 多重链表")]),t._v(" "),r("p",[r("img",{attrs:{src:s(425),alt:"image-20200912231112979"}})]),t._v(" "),r("p",[t._v("例子")]),t._v(" "),r("p",[r("img",{attrs:{src:s(426),alt:"image-20200912231442246"}})]),t._v(" "),r("h3",{attrs:{id:"_2-2-1-什么是堆栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-什么是堆栈"}},[t._v("#")]),t._v(" 2.2.1 什么是堆栈")]),t._v(" "),r("h4",{attrs:{id:"中缀表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中缀表达式"}},[t._v("#")]),t._v(" 中缀表达式")]),t._v(" "),r("p",[t._v("人们书写的表达式")]),t._v(" "),r("h4",{attrs:{id:"后缀表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#后缀表达式"}},[t._v("#")]),t._v(" 后缀表达式")]),t._v(" "),r("p",[t._v("计算机使用的, 运算符在数字后面")]),t._v(" "),r("p",[r("img",{attrs:{src:s(427),alt:"image-20200912233512633"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(428),alt:"image-20200912233646465"}})]),t._v(" "),r("h4",{attrs:{id:"堆栈的抽象数据类型描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆栈的抽象数据类型描述"}},[t._v("#")]),t._v(" 堆栈的抽象数据类型描述")]),t._v(" "),r("p",[r("img",{attrs:{src:s(429),alt:"image-20200912233816269"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(430),alt:"image-20200912233905973"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(431),alt:"image-20200912234149536"}})]),t._v(" "),r("h3",{attrs:{id:"_2-2-2-栈的顺序存储实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-栈的顺序存储实现"}},[t._v("#")]),t._v(" 2.2.2 栈的顺序存储实现")]),t._v(" "),r("p",[r("img",{attrs:{src:s(432),alt:"image-20200913001816883"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(433),alt:"image-20200913002045030"}})]),t._v(" "),r("p",[t._v("2.2.3 栈的链式存储实现")]),t._v(" "),r("p",[t._v("用单向链表表示时, Top 应该位于表头.")]),t._v(" "),r("p",[t._v("若位于表尾, 由于是单向链表,")]),t._v(" "),r("p",[t._v("做插入操作时, 没问题;")]),t._v(" "),r("p",[t._v("做删除操作时, 找不到前一个节点, 只能找到后一个节点.")]),t._v(" "),r("h4",{attrs:{id:"创建和判断是否为空操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建和判断是否为空操作"}},[t._v("#")]),t._v(" 创建和判断是否为空操作")]),t._v(" "),r("p",[r("img",{attrs:{src:s(434),alt:"image-20200913084731669"}})]),t._v(" "),r("h4",{attrs:{id:"push"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#push"}},[t._v("#")]),t._v(" Push")]),t._v(" "),r("p",[r("img",{attrs:{src:s(435),alt:"image-20200913085115325"}})]),t._v(" "),r("h4",{attrs:{id:"pop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pop"}},[t._v("#")]),t._v(" Pop")]),t._v(" "),r("p",[t._v("链表实现的队列不用判断是否为满, 因为是每次插入节点时申请空间, 不像数组那样, 元素个数固定.")]),t._v(" "),r("p",[r("img",{attrs:{src:s(436),alt:"image-20200913090059839"}})]),t._v(" "),r("h3",{attrs:{id:"_2-2-4-堆栈的应用-表达式求值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-堆栈的应用-表达式求值"}},[t._v("#")]),t._v(" 2.2.4 堆栈的应用: 表达式求值")]),t._v(" "),r("p",[r("img",{attrs:{src:s(437),alt:"image-20200913091308912"}})]),t._v(" "),r("h4",{attrs:{id:"中缀表达式转后缀表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中缀表达式转后缀表达式"}},[t._v("#")]),t._v(" 中缀表达式转后缀表达式")]),t._v(" "),r("p",[r("img",{attrs:{src:s(438),alt:"image-20200913091757522"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(439),alt:"image-20200913092003834"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(440),alt:"image-20200913092137171"}})]),t._v(" "),r("h4",{attrs:{id:"堆栈的其他应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆栈的其他应用"}},[t._v("#")]),t._v(" 堆栈的其他应用")]),t._v(" "),r("ul",[r("li",[t._v("函数调用以及递归实现")]),t._v(" "),r("li",[t._v("深度优先搜索")]),t._v(" "),r("li",[t._v("回朔算法(迷宫问题)")])]),t._v(" "),r("h3",{attrs:{id:"_2-3-1-队列及顺序存储实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-队列及顺序存储实现"}},[t._v("#")]),t._v(" 2.3.1 队列及顺序存储实现")]),t._v(" "),r("h4",{attrs:{id:"什么是队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是队列"}},[t._v("#")]),t._v(" 什么是队列")]),t._v(" "),r("p",[r("img",{attrs:{src:s(441),alt:"image-20200913092805271"}})]),t._v(" "),r("h4",{attrs:{id:"队列的抽象数据类型描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列的抽象数据类型描述"}},[t._v("#")]),t._v(" 队列的抽象数据类型描述")]),t._v(" "),r("p",[r("img",{attrs:{src:s(442),alt:"image-20200913092922964"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(443),alt:"image-20200913093150196"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(444),alt:"image-20200913101209154"}})]),t._v(" "),r("p",[t._v("顺环队列能造成空和满无法判断的情况 Rear 和 Front 指针重合时 既可以为空 也可以为满. 这里用的方法 2 解决")]),t._v(" "),r("p",[r("img",{attrs:{src:s(445),alt:"image-20200913101647714"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(446),alt:"image-20200913103315003"}})]),t._v(" "),r("h3",{attrs:{id:"_2-3-2-队列的链式存储实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-队列的链式存储实现"}},[t._v("#")]),t._v(" 2.3.2 队列的链式存储实现")]),t._v(" "),r("p",[t._v("用单向链表:")]),t._v(" "),r("ul",[r("li",[t._v("链表头做队列 front(出队列的地方)")]),t._v(" "),r("li",[t._v("链表尾做队列 rear(入队列的地方)")])]),t._v(" "),r("p",[t._v("因为链表尾删除有问题, 不能找到上一个的指针(单向链表的原因, 只能找到后一个指针, 不能找到前面的指针), 所以选择链表头当队列 front")]),t._v(" "),r("p",[r("img",{attrs:{src:s(447),alt:"image-20200913104805278"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(448),alt:"image-20200913105549442"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(449),alt:"image-20200913110121688"}})]),t._v(" "),r("h3",{attrs:{id:"_2-4-多项式的加减运算实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-多项式的加减运算实现"}},[t._v("#")]),t._v(" 2.4 多项式的加减运算实现")]),t._v(" "),r("h4",{attrs:{id:"多项式加法运算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多项式加法运算"}},[t._v("#")]),t._v(" 多项式加法运算")]),t._v(" "),r("p",[r("img",{attrs:{src:s(450),alt:"image-20200913110330650"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(451),alt:"image-20200913110449691"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(452),alt:"image-20200913111638445"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(453),alt:"image-20200913112612511"}})]),t._v(" "),r("p",[r("img",{attrs:{src:s(454),alt:"image-20200913112923610"}})]),t._v(" "),r("h3",{attrs:{id:"多项式计算小白专场"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多项式计算小白专场"}},[t._v("#")]),t._v(" 多项式计算小白专场")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("数据结构设计"),r("img",{attrs:{src:s(455),alt:"image-20200913114215040"}})])]),t._v(" "),r("li",[r("p",[r("img",{attrs:{src:s(456),alt:"image-20200913171054983"}})])]),t._v(" "),r("li",[r("p",[t._v("未完待续")]),t._v(" "),r("p",[t._v("https://www.bilibili.com/video/BV1JW411i731?p=25")])])]),t._v(" "),r("h2",{attrs:{id:"第三章-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第三章-树"}},[t._v("#")]),t._v(" 第三章 树")])])}),[],!1,null,null,null);a.default=e.exports}}]);